#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Farben fuer Programmlisting
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{listings,xcolor}

\definecolor{foreground}{HTML}{D8D8D8}
\definecolor{background}{HTML}{2F2F2F}
\definecolor{selectionForeground}{HTML}{D0D0D0}
\definecolor{selectionBackground}{HTML}{000000}
\definecolor{currentLine}{HTML}{2A2A2A}
\definecolor{lineNumber}{HTML}{D0D0D0}
\definecolor{searchResultIndication}{HTML}{000000}
\definecolor{filteredSearchResultIndication}{HTML}{000000}
\definecolor{occurrenceIndication}{HTML}{000000}
\definecolor{writeOccurrenceIndication}{HTML}{000000}
\definecolor{findScope}{HTML}{111111}
\definecolor{sourceHoverBackground}{HTML}{000000}
\definecolor{singleLineComment}{HTML}{6D6D6D}
\definecolor{multiLineComment}{HTML}{6D6D6D}
\definecolor{commentTaskTag}{HTML}{6D6D6D}
\definecolor{javadoc}{HTML}{808080}
\definecolor{javadocLink}{HTML}{a0a0a0}
\definecolor{javadocTag}{HTML}{a0a0a0}
\definecolor{javadocKeyword}{HTML}{a0a0a0}
\definecolor{class}{HTML}{2672c3}
\definecolor{interface}{HTML}{BA31FF}
\definecolor{method}{HTML}{2ba141}
\definecolor{methodDeclaration}{HTML}{777777}
\definecolor{bracket}{HTML}{e6e6fa}
\definecolor{number}{HTML}{4d87bb}
\definecolor{string}{HTML}{17c6a3}
\definecolor{operator}{HTML}{e6e6fa}
\definecolor{keyword}{HTML}{9c4530}
\definecolor{annotation}{HTML}{FFFFFF}
\definecolor{staticMethod}{HTML}{777777}
\definecolor{localVariable}{HTML}{79ABFF}
\definecolor{localVariableDeclaration}{HTML}{BED6FF}
\definecolor{field}{HTML}{777777}
\definecolor{staticField}{HTML}{777777}
\definecolor{staticFinalField}{HTML}{777777}
\definecolor{deprecatedMember}{HTML}{777777}
\definecolor{deletionIndication}{HTML}{777777}
\definecolor{enum}{HTML}{777777}
\definecolor{inheritedMethod}{HTML}{777777}
\definecolor{abstractMethod}{HTML}{777777}
\definecolor{parameterVariable}{HTML}{777777}
\definecolor{typeArgument}{HTML}{777777}
\definecolor{typeParameter}{HTML} {777777}
\definecolor{constant}{HTML}{b77730}

%%777777 --> filler


% Vordefiniertes Programmlisting
\lstset{
language = Java,
basicstyle = \small\sffamily,
backgroundcolor = \color{background},
stringstyle = \color{string},
keywordstyle = \color{keyword}\bfseries,
commentstyle = \color{singleLineComment}\itshape,
frame = lrbt,
frameround =tttt,
numbers = left,
numberstyle = \color{number},
showstringspaces = false,
breaklines = true,
xleftmargin = 15pt,
emph = [1]{Java},
emphstyle = [1]\color{black},
emph = [2]{if,and,or,else},
emphstyle = [2]\color{interface},
emph = [3]{Exception},
emphstyle = [3]\color{localVariable},
emph = [4]{expected},
emphstyle = [4]\color{localVariable},
emph = [5]{@Test,@param,@author},
emphstyle = [5]\color{javadocLink},
emph = [6]{out,MIN_VALUE,MAX_VALUE,MIN,MAX},
emphstyle = [6]\color{localVariableDeclaration}
}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language ngerman
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1.5cm
\topmargin 1.5cm
\rightmargin 1.5cm
\bottommargin 1.5cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip smallskip
\is_math_indent 0
\math_numbering_side default
\quotes_style german
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Belegarbeit Teil II
\begin_inset Newline newline
\end_inset

zur Veranstaltung Computergrafik und Visualisierung II
\end_layout

\begin_layout Author
Günther, Emanuel s76954 - Leopold, Michael s76904 - Fleischer, Kassandra
 s77282
\end_layout

\begin_layout Date
SoSe 2019
\end_layout

\begin_layout Section
Aufgabenstellung
\end_layout

\begin_layout Enumerate

\series bold
Integration von Schwarmverhalten [20 Punkte]
\series default

\begin_inset Newline newline
\end_inset

Integrieren Sie die notwendigen Methoden für die Realisierung eines Schwarmverha
ltens.
 Achten Sie dabei auf ein sinnvolles Konzept.
 Überlegen Sie sich ein geeignetes Projekt, in dem Sie Schwarmverhalten
 einsetzen wollen.
 Achten Sie auf die individuellen Bewegungs- und Handlungsmöglichkeiten
 und adaptieren Sie Ihre Implementierung des Schwarmverhaltens auf das Projekt.
\end_layout

\begin_layout Enumerate

\series bold
Shader-Visualisierung [10 Punkte]
\series default

\begin_inset Newline newline
\end_inset

Visualisieren Sie einen Schwarm im FragmentShader.
 Dazu könnten Sie beispielsweise die Individuen durch einfache OpenGL-Primitive
 konstruieren.
\end_layout

\begin_layout Enumerate

\series bold
Shader-Berechnunge[20 Zusatzpunkte und jede Menge Ruhm und Ehre]
\series default
 
\begin_inset Newline newline
\end_inset

Als Herausforderung können Sie versuchen, den Code aus der vorhergehenden
 Aufgabe so anzupassen, dass die update-Methode (die Aktualisierung aller
 notwendigen Kräfte und damit auch der einzelnen Positionen) durch einen
 VertexShader realisiert werden.
 Wer das vorstellen kann, wird in die CG-II-Hall-of-Fame aufgenommen.
\end_layout

\begin_layout Section
Lösung
\end_layout

\begin_layout Standard
Die vollständigen Lösungen wurden per Email abgegeben.
 Hier ein Auszug der verwendeten Konzepte und Shader.
\end_layout

\begin_layout Standard
Die Lösung wurde in 
\family typewriter
Eclipse 2019-03
\family default
 entwickelt.
\end_layout

\begin_layout Subsection
Idee/Konzept
\end_layout

\begin_layout Standard
Unsere Idee eine Vogelsimulation mit Spielcharakter.
 Es werden ein Schwarm von Vögeln sowie ein Raubvogel simuliert.
 
\end_layout

\begin_layout Standard
Die Steuerung des Raubvogels erfolgt über die Tastatur ({W, A, S, D} oder
 Pfeiltasten).
 Der Vogelschwarm wird mit der Maus gesteuert.
\end_layout

\begin_layout Subsubsection
Vogelschwarm
\end_layout

\begin_layout Standard
Auf jeden einzelnen Vogel des Schwarms wirken drei Kräfte, die das Schwarmverhal
ten simulieren.
 Diese sind Seperation, Angleichung und Zusammenhalt.
 Seperation bewirkt, dass jeder Vogel seinen eigenen Freiraum besitzt.
 Durch die Angleichung bewegen sich alle Vögel in eine grundsätzlich ähnliche
 Richtung.
 Der Zusammenhalt sorgt dafür, dass die Vögel im Schwarm bleiben.
\end_layout

\begin_layout Standard
Zusätzlich zu den Kräften des Schwarmverhaltens werden die Vögel noch anderweiti
g beeinflusst.
 Zum einen bewegen sich die Vögel immer zur aktuellen Mausposition hin.
 Damit lässt sich der Schwarm steuern.
 Zum anderen fliehen die Vögel vor dem Raubvogel.
 Dieser stellt einen Fressfeind dar.
 
\end_layout

\begin_layout Standard
Um einen natürlichen Bewegungsfluss zu simulieren, müssen alle einwirkenden
 Kräfte gewichtet werden.
 Die Seperationskraft ist wesentlich stärker als die der Angleichung oder
 die des Zusammenhalts.
 Die Kräfte der Maus und des Raubvogels besitzen etwa die selbe Gewichtung
 wie die des Zusammenhaltes.
 Die Vögel bewegen sich immer mit maximaler Geschwindigkeit.
\end_layout

\begin_layout Standard
Die Visualiserung der Vögel erfolgt über Dreiecke.
 Sie werden entsprechend ihrer jeweiligen Bewegungsrichtung rotiert.
\end_layout

\begin_layout Subsubsection
Raubvogel
\end_layout

\begin_layout Standard
Auf dem Raubvogel wirken die Kräfte der Steuerungstasten.
 Außerdem bewegt sich der Raubvogel immer mindestens mit Minimal-, höchstens
 aber mit Maximalgeschwindigkeit.
\end_layout

\begin_layout Standard
Die Visualisierung des Raubvogels erfolgt als Pentagon.
 Dieses wird, genau wie bei der Darstellung der Vögel, entsprechend der
 Bewegungsrichtung rotiert.
\end_layout

\begin_layout Subsection
Details zur Implementierung
\end_layout

\begin_layout Standard
Diese Klasse bildet den Kern unseres Programmes.
 In ihr werden die entsprechenden 3D-Modelle und deren Verhalten zusammen
 gebracht und zur eigentlichen Ausführung genutzt.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Java,numbers=left,basicstyle={\scriptsize\ttfamily},tabsize=4,backgroundcolor={\color[rgb]{0.8588,1,0.7333}},frame=single,xleftmargin=15pt"
inline false
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Klasse 
\family typewriter
Vogelsimulation
\end_layout

\begin_layout Standard
Die Klasse 
\family typewriter
Vogelsimulation
\family default
 stellt den Einstiegspunkt in das Projekt dar.
 In ihr werden das LWJGL-Fenster initialisiert, die Shader geladen, kompiliert
 und verlinkt, der Vogelschwarm und der Raubvogel angelegt sowie der Renderloop
 samt Transformationen ausgeführt.
\end_layout

\begin_layout Subsubsection
Klasse 
\family typewriter
Vogelschwarm
\end_layout

\begin_layout Standard
In der Vogelschwarm-Klasse werden alle Vögel eines Schwarmes verwaltet.
 Sie ist mithilfe des Singleton-Patterns implementiert, d.h.
 es gibt nur eine Instanz dieser Klasse.
 Folgende Methoden implementieren das Pattern:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Java,numbers=left,basicstyle={\scriptsize\ttfamily},tabsize=4,backgroundcolor={\color[rgb]{0.8588,1,0.7333}},frame=single,xleftmargin=15pt"
inline false
status open

\begin_layout Plain Layout

private Vogelschwarm() {
\end_layout

\begin_layout Plain Layout

	schwarm = new ArrayList<Vogel>();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

public static Vogelschwarm getInstance() {
\end_layout

\begin_layout Plain Layout

	return exemplar;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

public Object clone() throws CloneNotSupportedException {
\end_layout

\begin_layout Plain Layout

	throw new CloneNotSupportedException("Es gibt nur EINEN Schwarm.");
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Zur Verwaltung der Vögel existieren die Methoden 
\family typewriter
update()
\family default
 und 
\family typewriter
render()
\family default
.
 Sie leiten den jeweiligen Befehl an alle Vögel des Schwarms weiter.
\end_layout

\begin_layout Subsubsection
Klasse 
\family typewriter
Vogel
\end_layout

\begin_layout Standard
Jeder Vogel erbt von der Klasse BeweglichesObjekt.
 Unter anderem besitzt er eine boolsche Membervariable 
\family typewriter
gefressen
\family default
, die auf 
\family typewriter
true
\family default
 gesetzt wird, wenn der Vogel vom Raubvogel gefressen wurde.
 Außerdem sind die Methoden 
\family typewriter
update()
\family default
 und 
\family typewriter
render()
\family default
 implementiert, die jeweils nur ausgeführt werden, wenn der Vogel noch nicht
 gefressen wurde.
 Die Methode 
\family typewriter
update()
\family default
 leitet den Update-Befehl in diesem Fall an das entsprechende Schwarmverhalten
 weiter.
\end_layout

\begin_layout Subsubsection
Klasse 
\family typewriter
Schwarmverhalten
\end_layout

\begin_layout Standard
Im Schwarmverhalten werden alle Kräfte berechnet, die zur Berechnung der
 nächsten Position notwendig sind.
 Dazu gehören zum einen Methoden für das Schwarmverhalten (
\family typewriter
seperation()
\family default
, 
\family typewriter
angleichung()
\family default
, 
\family typewriter
zusammenhalt()
\family default
).
 Zum anderen sind das Methoden zur Mausverfolgung und zur Flucht vor dem
 Raubvogel.
\end_layout

\begin_layout Standard
Bei der Kraft zur Flucht vor dem Raubvogel wird der Vektor zwischen Raubvogel
 und Vogel berechnet und normiert.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Java,numbers=left,basicstyle={\scriptsize\ttfamily},tabsize=4,backgroundcolor={\color[rgb]{0.8588,1,0.7333}},frame=single,xleftmargin=15pt"
inline false
status open

\begin_layout Plain Layout

public Vektor3D flieheVorRaubvogel() {
\end_layout

\begin_layout Plain Layout

	Vektor3D force = new Vektor3D();
\end_layout

\begin_layout Plain Layout

	int max = 15 * (int)dist;
\end_layout

\begin_layout Plain Layout

	try {
\end_layout

\begin_layout Plain Layout

		int dis = (int)LineareAlgebra.euklDistance(vogel.pos, raubvogel.pos);
\end_layout

\begin_layout Plain Layout

		if (dis < max) {
\end_layout

\begin_layout Plain Layout

			force.add(LineareAlgebra.sub(vogel.pos, raubvogel.pos));
\end_layout

\begin_layout Plain Layout

			force.normalize();
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	} catch (Exception e) {
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	return force;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In der Methode 
\family typewriter
update()
\family default
 werden alle diese Kräfte übernommen, gewichtet und auf die Geschwindigkeit
 und Position des Vogels angewendet.
\end_layout

\begin_layout Subsubsection
Klasse 
\family typewriter
Raubvogel
\end_layout

\begin_layout Standard
asdjasldjh
\end_layout

\begin_layout Subsection
Shader
\end_layout

\begin_layout Subsubsection
Klasse 
\family typewriter
LoadShader
\end_layout

\begin_layout Standard
Die Klasse LoadShader besitzt einen privaten Konstruktor und stellt eine
 statische Klasse zur Verfügung, die den Shadercode aus einer Datei liest
 und diesen als String bereitstellt.
\begin_inset listings
lstparams "language=Java,numbers=left,basicstyle={\scriptsize\ttfamily},tabsize=4,backgroundcolor={\color[rgb]{0.8588,1,0.7333}},frame=single,xleftmargin=15pt"
inline false
status open

\begin_layout Plain Layout

public static String load(String src) {
\end_layout

\begin_layout Plain Layout

	File f = new File(src);
\end_layout

\begin_layout Plain Layout

	FileInputStream fis;
\end_layout

\begin_layout Plain Layout

	ByteArrayOutputStream bas = new ByteArrayOutputStream();
\end_layout

\begin_layout Plain Layout

	int len; //number of read bytes
\end_layout

\begin_layout Plain Layout

	byte[] buf = new byte[1024];
\end_layout

\begin_layout Plain Layout

	try {
\end_layout

\begin_layout Plain Layout

		fis = new FileInputStream(f);
\end_layout

\begin_layout Plain Layout

		while ((len = fis.read(buf)) > -1) {
\end_layout

\begin_layout Plain Layout

			bas.write(buf, 0, len);
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	} catch (Exception e) {
\end_layout

\begin_layout Plain Layout

		System.out.println(e);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	String code = new String(bas.toByteArray());
\end_layout

\begin_layout Plain Layout

	System.out.println(code);
\end_layout

\begin_layout Plain Layout

	return code;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection

\family typewriter
Vertexshader
\end_layout

\begin_layout Standard
Im Vertexshader wird mithilfe der ModelViewProjectionMatrix der jeweilige
 Vertex an seine Zielposition verschoben.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Java,numbers=left,basicstyle={\scriptsize\ttfamily},tabsize=4,backgroundcolor={\color[rgb]{0.8588,1,0.7333}},frame=single,xleftmargin=15pt"
inline false
status open

\begin_layout Plain Layout

void main() {
\end_layout

\begin_layout Plain Layout

	gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Dabei wird eine orthografische Projektion angewendet, sodass mit ganzzahligen
 Pixelwerten in der Größe der Fenstermaße gearbeitet werden kann.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Java,numbers=left,basicstyle={\scriptsize\ttfamily},tabsize=4,backgroundcolor={\color[rgb]{0.8588,1,0.7333}},frame=single,xleftmargin=15pt"
inline false
status open

\begin_layout Plain Layout

glMatrixMode(GL_PROJECTION);
\end_layout

\begin_layout Plain Layout

glLoadIdentity();
\end_layout

\begin_layout Plain Layout

glOrtho(0, WIDTH, HEIGHT, 0, 0, 1);
\end_layout

\begin_layout Plain Layout

glMatrixMode(GL_MODELVIEW);
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection

\family typewriter
Fragmentshader
\end_layout

\begin_layout Standard
Der Fragmentshader zeichnet alle betroffenen Pixel schwarz.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Java,numbers=left,basicstyle={\scriptsize\ttfamily},tabsize=4,backgroundcolor={\color[rgb]{0.8588,1,0.7333}},frame=single,xleftmargin=15pt"
inline false
status open

\begin_layout Plain Layout

void main() {
\end_layout

\begin_layout Plain Layout

	gl_FragColor = vec4(0, 0, 0, 1.0);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "block 2019"
literal "true"

\end_inset

Block-Berlitz M.: 
\begin_inset Quotes eld
\end_inset


\emph on
Warum sich der Dino furchtbar erschreckte - Lehrbuch zu Beleuchtung und
 Rendering mit Java, LWJGL, OpenGL und GLSL
\emph default

\begin_inset Quotes erd
\end_inset

, vividus Wissenschaftsverlag, 2019 (to appear :) )
\end_layout

\end_body
\end_document
